{"version":3,"file":"payment.js","sourceRoot":"","sources":["../../sdk/payment.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  createAssociatedTokenAccountIdempotentInstruction,\n  getAssociatedTokenAddressSync,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport type {\n  AccountMeta,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nimport { fetchIdlAccount } from \"./accounts\";\nimport type { PaymentInfo, PaymentShare } from \"./constants\";\n\nexport const BASIS_POINTS_DIVISOR = 10_000;\n\nexport const withRemainingAccountsForPaymentInfo = async (\n  connection: Connection,\n  transaction: Transaction,\n  payer: PublicKey,\n  paymentInfo: PublicKey\n): Promise<AccountMeta[]> => {\n  const paymentInfoData = await fetchIdlAccount(\n    connection,\n    paymentInfo,\n    \"paymentInfo\"\n  );\n  const remainingAccounts: AccountMeta[] = [\n    {\n      pubkey: paymentInfo,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n\n  // add payer\n  if (Number(paymentInfoData.parsed.paymentAmount) === 0)\n    return remainingAccounts;\n\n  remainingAccounts.push(\n    ...withRemainingAccountsForPayment(\n      transaction,\n      payer,\n      paymentInfoData.parsed.paymentMint,\n      (paymentInfoData.parsed.paymentShares as PaymentShare[]).map(\n        (p) => p.address\n      )\n    )\n  );\n  return remainingAccounts;\n};\n\nexport const withRemainingAccountsForPaymentInfoSync = (\n  transaction: Transaction,\n  payer: PublicKey,\n  paymentInfoData: Pick<PaymentInfo, \"parsed\" | \"pubkey\">\n): AccountMeta[] => {\n  const remainingAccounts: AccountMeta[] = [\n    {\n      pubkey: paymentInfoData.pubkey,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n\n  // add payer\n  if (Number(paymentInfoData.parsed.paymentAmount) === 0)\n    return remainingAccounts;\n\n  remainingAccounts.push(\n    ...withRemainingAccountsForPayment(\n      transaction,\n      payer,\n      paymentInfoData.parsed.paymentMint,\n      (paymentInfoData.parsed.paymentShares as PaymentShare[]).map(\n        (p) => p.address\n      )\n    )\n  );\n  return remainingAccounts;\n};\n\nexport const withRemainingAccountsForPayment = (\n  transaction: Transaction,\n  payer: PublicKey,\n  paymentMint: PublicKey,\n  paymentTargets: PublicKey[]\n): AccountMeta[] => {\n  const remainingAccounts = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n  ];\n\n  if (paymentMint.equals(PublicKey.default)) {\n    remainingAccounts.push({\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    });\n    remainingAccounts.push(\n      ...paymentTargets.map((a) => ({\n        pubkey: a,\n        isSigner: false,\n        isWritable: true,\n      }))\n    );\n  } else {\n    remainingAccounts.push({\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    });\n    remainingAccounts.push({\n      pubkey: getAssociatedTokenAddressSync(paymentMint, payer, true),\n      isSigner: false,\n      isWritable: true,\n    });\n    const ataIds = paymentTargets.map((a) =>\n      getAssociatedTokenAddressSync(paymentMint, a, true)\n    );\n    for (let i = 0; i < ataIds.length; i++) {\n      transaction.add(\n        createAssociatedTokenAccountIdempotentInstruction(\n          payer,\n          ataIds[i]!,\n          paymentTargets[i]!,\n          paymentMint\n        )\n      );\n    }\n    remainingAccounts.push(\n      ...ataIds.map((id) => ({\n        pubkey: id,\n        isSigner: false,\n        isWritable: true,\n      }))\n    );\n  }\n  return remainingAccounts;\n};\n\nexport const withRemainingAccounts = (\n  instruction: TransactionInstruction,\n  remainingAccounts: AccountMeta[]\n) => {\n  return {\n    ...instruction,\n    keys: [...instruction.keys, ...remainingAccounts],\n  };\n};\n"]}