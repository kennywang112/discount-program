{"version":3,"file":"rewardDistribution.js","sourceRoot":"","sources":["../../sdk/rewardDistribution.ts"],"names":[],"mappings":"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","sourcesContent":["import { BN } from \"@coral-xyz/anchor\";\nimport { getAccount, getAssociatedTokenAddressSync } from \"@solana/spl-token\";\nimport type { Connection, PublicKey } from \"@solana/web3.js\";\n\nimport { fetchIdlAccountDataById } from \"./accounts\";\nimport type { RewardDistributor, RewardEntry, StakeEntry } from \"./constants\";\nimport { findRewardEntryId } from \"./pda\";\nimport { findStakeEntryIdFromMint } from \"./utils\";\n\n/**\n * Get pending rewards of mintIds for a given reward distributor\n * @param connection\n * @param wallet\n * @param mintIds\n * @param rewardDistributor\n * @returns\n */\nexport const getPendingRewardsForPool = async (\n  connection: Connection,\n  wallet: PublicKey,\n  mintIds: PublicKey[],\n  rewardDistributor: RewardDistributor,\n  UTCNow: number\n): Promise<{\n  rewardMap: {\n    [mintId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  };\n  claimableRewards: BN;\n}> => {\n  const rewardDistributorTokenAccountId = getAssociatedTokenAddressSync(\n    rewardDistributor.parsed.rewardMint,\n    rewardDistributor.pubkey,\n    true\n  );\n  const rewardDistributorTokenAccountInfo = await getAccount(\n    connection,\n    rewardDistributorTokenAccountId\n  );\n\n  const stakeEntryIds: PublicKey[] = await Promise.all(\n    mintIds.map(\n      async (mintId) =>\n        await findStakeEntryIdFromMint(\n          connection,\n          rewardDistributor.parsed.stakePool,\n          mintId,\n          wallet\n        )\n    )\n  );\n\n  const rewardEntryIds = stakeEntryIds.map((stakeEntryId) =>\n    findRewardEntryId(rewardDistributor.pubkey, stakeEntryId)\n  );\n\n  const accountDataById = await fetchIdlAccountDataById(connection, [\n    ...stakeEntryIds,\n    ...rewardEntryIds,\n  ]);\n\n  const [stakeEntries, rewardEntries] = Object.values(accountDataById).reduce(\n    (acc, account) => {\n      if (account.type === \"stakeEntry\") {\n        return [[...acc[0], account], acc[1]];\n      } else if (account.type === \"rewardEntry\") {\n        return [acc[0], [...acc[1], account]];\n      }\n      return acc;\n    },\n    [[], []] as [StakeEntry[], RewardEntry[]]\n  );\n  return getRewardMap(\n    stakeEntries,\n    rewardEntries,\n    rewardDistributor,\n    new BN(rewardDistributorTokenAccountInfo.amount.toString()),\n    UTCNow\n  );\n};\n\n/**\n * Get the map of rewards for stakeEntry to rewards and next reward time\n * Also return the total claimable rewards from this map\n * @param stakeEntries\n * @param rewardEntries\n * @param rewardDistributor\n * @param remainingRewardAmount\n * @returns\n */\nexport const getRewardMap = (\n  stakeEntries: StakeEntry[],\n  rewardEntries: RewardEntry[],\n  rewardDistributor: RewardDistributor,\n  remainingRewardAmount: BN,\n  UTCNow: number\n): {\n  rewardMap: {\n    [stakeEntryId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  };\n  claimableRewards: BN;\n} => {\n  const rewardMap: {\n    [stakeEntryId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  } = {};\n\n  for (let i = 0; i < stakeEntries.length; i++) {\n    const stakeEntry = stakeEntries[i]!;\n    const rewardEntry = rewardEntries.find((rewardEntry) =>\n      rewardEntry?.parsed?.stakeEntry.equals(stakeEntry?.pubkey)\n    );\n\n    if (stakeEntry) {\n      const [claimableRewards, nextRewardsIn] = calculatePendingRewards(\n        rewardDistributor,\n        stakeEntry,\n        rewardEntry,\n        remainingRewardAmount,\n        UTCNow\n      );\n      rewardMap[stakeEntry.pubkey.toString()] = {\n        claimableRewards,\n        nextRewardsIn,\n      };\n    }\n  }\n\n  // Compute too many rewards\n  let claimableRewards = Object.values(rewardMap).reduce(\n    (acc, { claimableRewards }) => acc.add(claimableRewards),\n    new BN(0)\n  );\n\n  if (claimableRewards.gt(remainingRewardAmount)) {\n    claimableRewards = remainingRewardAmount;\n  }\n  return { rewardMap, claimableRewards };\n};\n\n/**\n * Calculate claimable rewards and next reward time for a give mint and reward and stake entry\n * @param rewardDistributor\n * @param stakeEntry\n * @param rewardEntry\n * @param remainingRewardAmount\n * @param UTCNow\n * @returns\n */\nexport const calculatePendingRewards = (\n  rewardDistributor: RewardDistributor,\n  stakeEntry: StakeEntry,\n  rewardEntry: RewardEntry | undefined,\n  remainingRewardAmount: BN,\n  UTCNow: number\n): [BN, BN] => {\n  if (\n    !stakeEntry ||\n    stakeEntry.parsed.pool.toString() !==\n      rewardDistributor.parsed.stakePool.toString()\n  ) {\n    return [new BN(0), new BN(0)];\n  }\n\n  const rewardSecondsReceived =\n    rewardEntry?.parsed.rewardSecondsReceived || new BN(0);\n  const multiplier =\n    rewardEntry?.parsed?.multiplier ||\n    rewardDistributor.parsed.defaultMultiplier;\n  const currentSeconds = stakeEntry.parsed.cooldownStartSeconds\n    ? new BN(stakeEntry.parsed.cooldownStartSeconds)\n    : new BN(UTCNow);\n\n  let rewardSeconds = currentSeconds\n    .sub(new BN(stakeEntry.parsed.lastStakedAt))\n    .mul(new BN(stakeEntry.parsed.amount))\n    .add(new BN(stakeEntry.parsed.totalStakeSeconds));\n\n  if (rewardDistributor.parsed.maxRewardSecondsReceived) {\n    rewardSeconds = BN.min(\n      rewardSeconds,\n      new BN(rewardDistributor.parsed.maxRewardSecondsReceived)\n    );\n  }\n\n  let rewardAmountToReceive = rewardSeconds\n    .sub(new BN(rewardSecondsReceived))\n    .div(new BN(rewardDistributor.parsed.rewardDurationSeconds))\n    .mul(new BN(rewardDistributor.parsed.rewardAmount))\n    .mul(new BN(multiplier))\n    .div(new BN(10).pow(new BN(rewardDistributor.parsed.multiplierDecimals)));\n\n  if (rewardAmountToReceive.gt(remainingRewardAmount)) {\n    rewardAmountToReceive = remainingRewardAmount;\n  }\n\n  const nextRewardsIn = new BN(\n    rewardDistributor.parsed.rewardDurationSeconds\n  ).sub(\n    currentSeconds\n      .sub(new BN(stakeEntry.parsed.lastStakedAt))\n      .add(new BN(stakeEntry.parsed.totalStakeSeconds))\n      .mod(new BN(rewardDistributor.parsed.rewardDurationSeconds))\n  );\n\n  return [rewardAmountToReceive, nextRewardsIn];\n};\n"]}